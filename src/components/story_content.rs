#![allow(unused_mut)]
use crate::contexts::language_context::LanguageState;
use crate::contexts::settings_context::use_settings_context;
use crate::contexts::story_context::use_story_context;
use crate::layout::KeyboardState;
use crate::pages::story::paragraph_has_translation;
use crate::services::indexeddb::{
    get_disabled_choices_from_indexeddb, set_disabled_choice_to_indexeddb,
};
#[cfg(target_arch = "wasm32")]
use crate::services::indexeddb::set_setting_to_indexeddb;
use dioxus::prelude::*;
use dioxus_i18n::t;
use serde::{Deserialize, Serialize};
use serde_json;
use std::borrow::Cow;
use std::collections::hash_map::DefaultHasher;
use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::sync::Arc;
use wasm_bindgen::JsCast;
use wasm_bindgen_futures::spawn_local;
use web_sys::{Document, Window};
fn escape_html(text: &str) -> String {
    let mut escaped = String::with_capacity(text.len());
    for ch in text.chars() {
        match ch {
            '&' => escaped.push_str("&amp;"),
            '<' => escaped.push_str("&lt;"),
            '>' => escaped.push_str("&gt;"),
            '"' => escaped.push_str("&quot;"),
            '\'' => escaped.push_str("&#39;"),
            _ => escaped.push(ch),
        }
    }
    escaped
}

#[derive(Props, Clone, PartialEq)]
pub struct StoryContentProps {
    pub paragraph: Signal<String>,
    pub choices: Vec<Choice>,
    pub on_choice_click: EventHandler<(String, usize)>,
    pub on_toggle_reader_mode: EventHandler<MouseEvent>,
    pub enabled_choices: HashSet<String>,
    pub countdowns: Signal<Vec<u32>>,
    pub max_times: Signal<Vec<u32>>,
    pub progress_started: Signal<Vec<bool>>,
    pub disabled_by_countdown: Signal<Vec<bool>>,
    pub reader_mode: bool,
    pub chapter_title: String,
    pub current_paragraph_id: Signal<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Choice {
    pub caption: Cow<'static, str>,
    pub action: Action,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Action {
    #[serde(rename = "type")]
    pub type_: Cow<'static, str>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
    pub to: Cow<'static, str>,
}

impl From<crate::components::translation_form::ParagraphChoice> for Choice {
    fn from(choice: crate::components::translation_form::ParagraphChoice) -> Self {
        Self {
            caption: String::new().into(), // caption is now generated by frontend
            action: Action {
                type_: choice.get_type().into(),
                key: choice.get_key(),
                value: choice.get_value(),
                to: choice.get_to().into(),
            },
        }
    }
}

impl From<crate::models::story::Choice> for Choice {
    fn from(choice: crate::models::story::Choice) -> Self {
        Self {
            caption: choice.caption.into(),
            action: Action {
                type_: choice.action.type_.into(),
                key: choice.action.key,
                value: choice.action.value,
                to: choice.action.to.first().cloned().unwrap_or_default().into(),
            },
        }
    }
}

fn get_window_document() -> Option<(Window, Document)> {
    let window = web_sys::window()?;
    let document = window.document()?;
    Some((window, document))
}

#[derive(Props, Clone, PartialEq)]
pub struct StoryContentUIProps {
    pub paragraph: String,
    pub choices: Vec<Choice>,
    pub enabled_choices: HashSet<String>,
    pub disabled_by_countdown: Vec<bool>,
    pub chapter_title: String,
}

#[component]
pub fn StoryContentUI(props: StoryContentUIProps) -> Element {
    rsx! {
        div {
            class: "w-full flex items-center justify-center min-h-[calc(100vh-56px)]",
            div {
                class: "text-3xl md:text-4xl text-gray-900 dark:text-white paper:text-[#1f2937] text-center w-full select-none flex items-center justify-center",
                style: "letter-spacing: 0.1em;",
                dangerous_inner_html: escape_html(&props.chapter_title),
            }
        }
        article {
            class: "prose-sm dark:prose-invert lg:prose-base mx-auto max-w-3xl p-8 text-gray-900 dark:text-white paper:text-[#1f2937] paper:prose paper:prose-base paper:bg-transparent bg-white dark:bg-transparent",
            div {
                class: "whitespace-pre-wrap space-y-8 story-text-filter",
                {props.paragraph.split('\n')
                    .filter(|p| !p.trim().is_empty())
                    .map(|p| rsx! {
                        p {
                            class: "indent-10 tracking-wide leading-relaxed text-justify paper:text-[#1f2937]",
                            dangerous_inner_html: escape_html(p),
                        }
                    })
                }
            }
            ol {
                class: "mt-10 w-full md:w-fit list-decimal space-y-3",
                {props.choices.iter().enumerate().map(|(index, choice)| {
                    let caption = &choice.caption;
                    let is_enabled = props.enabled_choices.contains(&caption.as_ref().to_string())
                        && !props.disabled_by_countdown.get(index).copied().unwrap_or(false);
                    rsx! {
                        li {
                            class: {{
                                let base = "p-4 rounded-lg transition duration-200 relative border border-transparent paper:bg-transparent text-gray-900 dark:text-gray-100 paper:!text-[#1f2937]";
                                let enabled = "cursor-pointer hover:text-gray-700 dark:hover:text-gray-300 paper:hover:!text-[#111827] transition-opacity transition-transform";
                                let disabled = "opacity-50 cursor-not-allowed text-gray-400 dark:text-gray-400 paper:!text-[#9ca3af]";
                                format!("{base} {}", if is_enabled { enabled } else { disabled })
                            }},
                            span { class: "mr-2", dangerous_inner_html: escape_html(caption.as_ref()) }
                        }
                    }
                })}
            }
        }
    }
}

#[component]
pub fn StoryContent(props: StoryContentProps) -> Element {
    let choices = Arc::new(props.choices.clone());
    let enabled_choices = Arc::new(props.enabled_choices.clone());
    let on_choice_click = props.on_choice_click.clone();
    let mut keyboard_state = use_context::<Signal<KeyboardState>>();
    let story_ctx = use_story_context();
    let settings_ctx = use_settings_context();
    let mut show_paper_tutorial = use_signal(|| false);
    let mut pointer_start = use_signal(|| None::<(f64, f64)>);
    let mut countdowns = props.countdowns.clone();
    let mut max_times = props.max_times.clone();
    let mut progress_started = props.progress_started.clone();
    let mut disabled_by_countdown = props.disabled_by_countdown.clone();

    // Use current paragraph ID signal passed from props
    let current_paragraph_id_signal = props.current_paragraph_id.clone();
    let disabled_state_loaded = use_signal(|| false);
    let language_state = use_context::<Signal<LanguageState>>();
    // Current interface language
    let current_language = language_state.read().current_language.clone();
    // Snapshot of all paragraphs for translation lookup
    let paragraphs_vec = story_ctx.read().paragraphs.read().clone();
    let paragraphs_vec_keydown = paragraphs_vec.clone();
    let current_language_keydown = current_language.clone();
    let theme_mode = settings_ctx
        .read()
        .settings
        .get("theme_mode")
        .cloned()
        .unwrap_or_else(|| "auto".to_string());
    let page_turn_mode = settings_ctx
        .read()
        .settings
        .get("page_turn_mode")
        .cloned()
        .unwrap_or_else(|| {
            if theme_mode == "paper" {
                "horizontal".to_string()
            } else {
                "scroll".to_string()
            }
        });
    let tutorial_message = match page_turn_mode.as_str() {
        "horizontal" => t!("paper_tutorial_body_left_right"),
        "vertical" => t!("paper_tutorial_body_up_down"),
        _ => t!("paper_tutorial_body_scroll"),
    };

    {
        let mut show_paper_tutorial = show_paper_tutorial.clone();
        let settings_ctx = settings_ctx.clone();
        let theme_mode = theme_mode.clone();
        use_effect(move || {
            let tutorial_seen = settings_ctx
                .read()
                .settings
                .get("paper_mode_tutorial_seen")
                .map(|v| v == "true")
                .unwrap_or(false);
            if theme_mode == "paper" && !tutorial_seen {
                show_paper_tutorial.set(true);
            } else {
                show_paper_tutorial.set(false);
            }
            ()
        });
    }
    {
        let mut story_ctx = story_ctx.clone();
        let mut disabled_by_countdown = disabled_by_countdown.clone();
        let mut countdowns = countdowns.clone();
        let mut max_times = max_times.clone();
        let mut progress_started = progress_started.clone();
        use_effect(move || {
            // 1. 取得 global 倒數並套用 disabled 遮罩
            let mut source = story_ctx.read().countdowns.read().clone();
            if let Ok(mask) = disabled_by_countdown.try_read() {
                for (i, disabled) in mask.iter().enumerate() {
                    if *disabled && i < source.len() {
                        source[i] = 0;
                    }
                }
            }

            // 2. 決定是否需要更新各 signal
            let need_update_countdowns = countdowns.read().as_slice() != source.as_slice();
            let need_update_max_times = max_times.read().as_slice() != source.as_slice();
            let desired_len = source.len();
            let need_resize_progress =
                progress_started.try_read().map(|v| v.len()).unwrap_or(0) != desired_len;
            let need_resize_disabled = disabled_by_countdown
                .try_read()
                .map(|v| v.len())
                .unwrap_or(0)
                != desired_len;

            // 3. 在下一個事件迴圈中批次寫入，避免在同一 reactive scope 內同時讀寫
            if need_update_countdowns
                || need_update_max_times
                || need_resize_progress
                || need_resize_disabled
            {
                gloo_timers::callback::Timeout::new(0, move || {
                    if need_update_countdowns {
                        countdowns.set(source.clone());
                    }
                    if need_update_max_times {
                        max_times.set(source.clone());
                    }
                    if need_resize_progress {
                        if let Ok(mut guard) = progress_started.try_write() {
                            *guard = vec![false; desired_len];
                        }
                    }
                    if need_resize_disabled {
                        if let Ok(mut guard) = disabled_by_countdown.try_write() {
                            guard.resize(desired_len, false);
                        }
                    }
                })
                .forget();
            }
        });
    }

    // Load disabled state from IndexedDB
    {
        let mut disabled_by_countdown = disabled_by_countdown.clone();
        let current_paragraph_id_signal = current_paragraph_id_signal.clone();
        let mut story_ctx = story_ctx.clone();
        let mut disabled_state_loaded = disabled_state_loaded.clone();
        use_effect(move || {
            let paragraph_id = current_paragraph_id_signal.read().clone();
            if paragraph_id.is_empty() {
                return;
            }

            // Skip if disabled state already loaded for this paragraph
            if *disabled_state_loaded.read() {
                return;
            }

            // Check if it's settings chapter, skip if true
            let is_settings_chapter = story_ctx.read().is_settings_chapter();
            if is_settings_chapter {
                return;
            }

            let paragraph_id_for_async = paragraph_id.clone();
            spawn_local(async move {
                if let Ok(js_value) =
                    get_disabled_choices_from_indexeddb(&paragraph_id_for_async).await
                {
                    let disabled_indices: Vec<usize> =
                        if let Ok(array) = js_value.dyn_into::<js_sys::Array>() {
                            array
                                .iter()
                                .filter_map(|v| v.as_f64().map(|n| n as usize))
                                .collect()
                        } else {
                            Vec::new()
                        };

                    // Always apply disabled state from IndexedDB (use try_read to avoid ValueDroppedError)
                    let mut current_disabled = disabled_by_countdown
                        .try_read()
                        .map(|v| v.clone())
                        .unwrap_or_default();
                    for &index in &disabled_indices {
                        if index < current_disabled.len() {
                            current_disabled[index] = true;
                        }
                    }
                    // Write back updated disabled vector safely
                    if let Ok(mut guard) = disabled_by_countdown.try_write() {
                        *guard = current_disabled;
                    }

                    // Also zero out countdown and max_time for disabled choices to avoid any countdown restart
                    {
                        // Step 1: immediately update the global story_ctx countdowns so that any sync impact
                        // sees the already-zeroed values and will not overwrite our local signals back to the
                        // original non-zero numbers.
                        if let Ok(mut ctx_write) = story_ctx.try_write() {
                            if let Ok(mut ctx_cd) = ctx_write.countdowns.try_write() {
                                for &idx in &disabled_indices {
                                    if idx < ctx_cd.len() {
                                        ctx_cd[idx] = 0;
                                    }
                                }
                            }
                        }

                        // Step 2: update local reactive signals.
                        if let Ok(mut c_guard) = countdowns.try_write() {
                            for &idx in &disabled_indices {
                                if idx < c_guard.len() {
                                    c_guard[idx] = 0;
                                }
                            }
                        }

                        if let Ok(mut m_guard) = max_times.try_write() {
                            for &idx in &disabled_indices {
                                if idx < m_guard.len() {
                                    m_guard[idx] = 0;
                                }
                            }
                        }

                        if let Ok(mut p_guard) = progress_started.try_write() {
                            for &idx in &disabled_indices {
                                if idx < p_guard.len() {
                                    p_guard[idx] = true;
                                }
                            }
                        }
                    }

                    // Mark that disabled state has completed loading (do this after all mutations to guarantee correct state)
                    disabled_state_loaded.set(true);
                }
            });
        });
    }

    let mut show_filter = use_signal(|| true);
    let mut is_focused = use_signal(|| false);
    let mut is_mobile = use_signal(|| false);
    let _is_countdown_paused = use_signal(|| true);
    let _has_shown_choices = use_signal(|| false);

    let is_mobile_memo = use_memo(move || {
        if let Some((window, _)) = get_window_document() {
            if let Ok(width) = window.inner_width() {
                if let Some(width) = width.as_f64() {
                    return width < 768.0;
                }
            }
        }
        false
    });

    use_effect(move || {
        let mobile = *is_mobile_memo.read();
        is_mobile.set(mobile);
        // Desktop (non-mobile) 預設顯示遮罩；Mobile 則關閉
        show_filter.set(!mobile);
    });

    // Listen for custom event show_filter, show overlay when received
    {
        let show_filter = show_filter.clone();
        use_effect(move || {
            if let Some((_, _document)) = get_window_document() {
                let mut show_filter = show_filter.clone();
                let handler = wasm_bindgen::closure::Closure::wrap(Box::new(
                    move |_event: web_sys::CustomEvent| {
                        // Safely set signal to avoid ValueDroppedError
                        if let Ok(mut guard) = show_filter.try_write() {
                            *guard = true;
                        }
                    },
                )
                    as Box<dyn FnMut(web_sys::CustomEvent)>);
                if let Ok(_) = _document.add_event_listener_with_callback(
                    "show_filter",
                    handler.as_ref().unchecked_ref(),
                ) {
                    handler.forget();
                }
            }
            (|| {})()
        });
    }

    let is_settings_chapter = story_ctx.read().is_settings_chapter();

    let has_countdown = use_memo(move || countdowns.read().iter().any(|&c| c > 0));
    let show_choices = use_signal(|| false);
    let is_countdown_paused = use_signal(|| true);
    let mut has_shown_choices = use_signal(|| false);
    let mut show_filter_clone = show_filter.clone();
    let mut show_choices_clone = show_choices.clone();
    let mut has_shown_choices_clone = has_shown_choices.clone();
    let mut is_countdown_paused_clone = is_countdown_paused.clone();

    // 初始顯示邏輯
    {
        let mut show_choices = show_choices_clone.clone();
        let mut has_shown_choices = has_shown_choices_clone.clone();
        let has_countdown = has_countdown.clone();
        let mut is_countdown_paused = is_countdown_paused.clone();
        use_effect(move || {
            if *has_countdown.read() {
                // 有倒數計時時，預設隱藏選項列表
                show_choices.set(false);
                has_shown_choices.set(false);
                // 確保倒數計時最初是暫停的
                is_countdown_paused.set(true);
            } else {
                // 沒有倒數計時時，直接顯示選項列表
                show_choices.set(true);
                has_shown_choices.set(true);
            }
            (|| {})()
        });
    }

    // 捲動檢查邏輯
    {
        let mut show_choices = show_choices_clone.clone();
        let mut has_shown_choices = has_shown_choices_clone.clone();
        let mut is_countdown_paused = is_countdown_paused_clone.clone();
        let mut progress_started = progress_started.clone();
        let show_filter = show_filter_clone.clone();

        use_effect(move || {
            // Helper closure for scroll position check
            let mut check_scroll = move || {
                // Only run when overlay is dismissed
                if show_filter.try_read().map(|v| *v).unwrap_or(true) {
                    return;
                }

                if let Some((_, document)) = get_window_document() {
                    if let Some(document_element) = document.document_element() {
                        let scroll_height = document_element.scroll_height();
                        let client_height = document_element.client_height();
                        let scroll_top = document_element.scroll_top();

                        let is_mobile_device = *is_mobile.read();
                        if is_scrolled_to_bottom(
                            scroll_height,
                            client_height,
                            scroll_top,
                            is_mobile_device,
                        ) {
                            // Schedule signal updates to avoid read→write loops
                            let show_needed = show_choices.try_read().map(|v| !*v).unwrap_or(true);
                            if show_needed {
                                let mut sc = show_choices.clone();
                                gloo_timers::callback::Timeout::new(0, move || {
                                    if let Ok(mut guard) = sc.try_write() {
                                        *guard = true;
                                    }
                                })
                                .forget();
                            }

                            let hsc_needed =
                                has_shown_choices.try_read().map(|v| !*v).unwrap_or(true);
                            if hsc_needed {
                                let mut hsc = has_shown_choices.clone();
                                gloo_timers::callback::Timeout::new(0, move || {
                                    if let Ok(mut guard) = hsc.try_write() {
                                        *guard = true;
                                    }
                                })
                                .forget();
                            }

                            let paused = is_countdown_paused.try_read().map(|v| *v).unwrap_or(true);
                            if paused {
                                let mut icp = is_countdown_paused.clone();
                                gloo_timers::callback::Timeout::new(0, move || {
                                    if let Ok(mut guard) = icp.try_write() {
                                        *guard = false;
                                    }
                                })
                                .forget();
                            }

                            // 同時在這裡設置 progress_started 為 true
                            let mut ps = progress_started.clone();
                            gloo_timers::callback::Timeout::new(0, move || {
                                if let Ok(mut guard) = ps.try_write() {
                                    // 將所有值設為 true，表示所有倒數計時開始
                                    for v in guard.iter_mut() {
                                        *v = true;
                                    }
                                }
                            })
                            .forget();
                        }
                    }
                }
            };

            // 執行一次初始檢查，排程在下一個事件迴圈，避免在 impact 執行階段對 signal 建立依賴
            gloo_timers::callback::Timeout::new(0, move || {
                check_scroll();
            })
            .forget();

            // 設置 scroll 事件監聽，只做一次
            if let Some(window) = web_sys::window() {
                let cb = wasm_bindgen::closure::Closure::wrap(Box::new(move || {
                    check_scroll();
                })
                    as Box<dyn FnMut()>);

                let _ =
                    window.add_event_listener_with_callback("scroll", cb.as_ref().unchecked_ref());

                cb.forget();
            }

            // 不需要清理函式，留空即可
            (|| {})()
        });
    }

    // 遮罩出現時的邏輯
    {
        let mut show_choices = show_choices_clone.clone();
        let mut is_countdown_paused = is_countdown_paused_clone.clone();
        let mut has_shown_choices = has_shown_choices_clone.clone();
        let show_filter = show_filter_clone.clone();
        use_effect(move || {
            if show_filter.try_read().map(|v| *v).unwrap_or(true) {
                let should_show = has_shown_choices.try_read().map(|v| *v).unwrap_or(false);
                let currently_showing = show_choices.try_read().map(|v| *v).unwrap_or(false);
                if should_show && !currently_showing {
                    let mut sc = show_choices.clone();
                    gloo_timers::callback::Timeout::new(0, move || {
                        if let Ok(mut guard) = sc.try_write() {
                            *guard = true;
                        }
                    })
                    .forget();
                }

                let paused = is_countdown_paused.try_read().map(|v| *v).unwrap_or(true);
                if !paused {
                    let mut icp = is_countdown_paused.clone();
                    gloo_timers::callback::Timeout::new(0, move || {
                        if let Ok(mut guard) = icp.try_write() {
                            *guard = true;
                        }
                    })
                    .forget();
                }
            }
            (|| {})()
        });
    }

    // 遮罩消失時的邏輯
    {
        let mut show_choices = show_choices_clone.clone();
        let mut is_countdown_paused = is_countdown_paused_clone.clone();
        let mut has_shown_choices = has_shown_choices_clone.clone();
        let show_filter = show_filter_clone.clone();
        let has_countdown = has_countdown.clone();
        use_effect(move || {
            if !show_filter.try_read().map(|v| *v).unwrap_or(false) {
                // Overlay dismissed
                let mut should_show_choices =
                    has_shown_choices.try_read().map(|v| *v).unwrap_or(false);

                // If there are countdowns and choices haven't been revealed yet, check scrollability
                if *has_countdown.read() && !should_show_choices {
                    if let Some((_, document)) = get_window_document() {
                        if let Some(document_element) = document.document_element() {
                            let scroll_height = document_element.scroll_height();
                            let client_height = document_element.client_height();
                            // When the content cannot scroll (content height within tolerance of the viewport height), force showing the choices
                            if (scroll_height - client_height) <= NON_SCROLLABLE_TOLERANCE {
                                should_show_choices = true;
                            }
                        }
                    }
                }

                if should_show_choices {
                    // Schedule updates to avoid read->write loop
                    let show_needed = show_choices.try_read().map(|v| !*v).unwrap_or(true);
                    if show_needed {
                        let mut sc = show_choices.clone();
                        gloo_timers::callback::Timeout::new(0, move || {
                            if let Ok(mut guard) = sc.try_write() {
                                *guard = true;
                            }
                        })
                        .forget();
                    }

                    let hsc_needed = has_shown_choices.try_read().map(|v| !*v).unwrap_or(true);
                    if hsc_needed {
                        let mut hsc = has_shown_choices.clone();
                        gloo_timers::callback::Timeout::new(0, move || {
                            if let Ok(mut guard) = hsc.try_write() {
                                *guard = true;
                            }
                        })
                        .forget();
                    }

                    let paused = is_countdown_paused.try_read().map(|v| *v).unwrap_or(true);
                    if paused {
                        let mut icp = is_countdown_paused.clone();
                        gloo_timers::callback::Timeout::new(0, move || {
                            if let Ok(mut guard) = icp.try_write() {
                                *guard = false;
                            }
                        })
                        .forget();
                    }
                }
            }
            (|| {})()
        });
    }

    // 同步 has_shown_choices <- show_choices
    {
        let show_choices = show_choices_clone.clone();
        let mut has_shown_choices = has_shown_choices_clone.clone();
        use_effect(move || {
            if *show_choices.read() {
                has_shown_choices.set(true);
            }
            (|| {})()
        });
    }

    // Animation class control
    let fadein_class = if *has_countdown.read() && *show_choices.read() {
        "animate-fadein-choices"
    } else {
        ""
    };
    // New: Control choice container visibility
    let choices_visible = *show_choices.read() || *show_filter.read();
    let choices_opacity_class = if choices_visible {
        "opacity-100 pointer-events-auto"
    } else {
        "opacity-0 pointer-events-none"
    };

    // Move is_countdown_paused reading outside the render loop to avoid scope issues
    let countdown_paused = *is_countdown_paused.read();

    // Check time_left setting
    let time_left_enabled = use_memo(move || {
        settings_ctx
            .read()
            .settings
            .get("time_left")
            .map(|v| v != "false")
            .unwrap_or(false) // Default to disabled
    });

    // Scroll lock impact: disable page scrolling when overlay is visible
    {
        let show_filter = show_filter.clone();
        use_effect(move || {
            let lock_scroll = *show_filter.read();
            if let Some((_, document)) = get_window_document() {
                if let Some(body) = document.body() {
                    if should_lock_page_scroll(lock_scroll) {
                        let _ = body.set_attribute("style", "overflow: hidden;");
                    } else {
                        let _ = body.remove_attribute("style");
                    }
                }
            }
            (|| {})()
        });
    }

    rsx! {
        div {
            class: "relative story-content-container",
            tabindex: "0",
            onpointerdown: {
                let theme_mode = theme_mode.clone();
                let page_turn_mode = page_turn_mode.clone();
                move |event: Event<PointerData>| {
                    if theme_mode != "paper" || page_turn_mode == "scroll" {
                        return;
                    }
                    if !event.data.is_primary() {
                        return;
                    }
                    let coords = event.data.client_coordinates();
                    pointer_start.set(Some((coords.x, coords.y)));
                }
            },
            onpointerup: {
                let theme_mode = theme_mode.clone();
                let page_turn_mode = page_turn_mode.clone();
                move |event: Event<PointerData>| {
                    if theme_mode != "paper" || page_turn_mode == "scroll" {
                        return;
                    }
                    if !event.data.is_primary() {
                        return;
                    }
                    let Some((start_x, start_y)) = *pointer_start.read() else {
                        return;
                    };
                    let coords = event.data.client_coordinates();
                    let dx = coords.x - start_x;
                    let dy = coords.y - start_y;
                    let threshold = 50.0;
                    let (is_forward, should_turn) = match page_turn_mode.as_str() {
                        "horizontal" => (dx < 0.0, dx.abs() > dy.abs() && dx.abs() > threshold),
                        "vertical" => (dy < 0.0, dy.abs() > dx.abs() && dy.abs() > threshold),
                        _ => (false, false),
                    };
                    if should_turn {
                        if let Some(window) = web_sys::window() {
                            let height = window
                                .inner_height()
                                .ok()
                                .and_then(|v| v.as_f64())
                                .unwrap_or(0.0);
                            let delta = if is_forward { height } else { -height };
                            if delta != 0.0 {
                                window.scroll_by_with_x_and_y(0.0, delta);
                            }
                        }
                    }
                    pointer_start.set(None);
                }
            },
            onpointercancel: move |_| {
                pointer_start.set(None);
            },
            onkeydown: move |event: Event<KeyboardData>| {
                match event.data.key() {
                    key => {
                        if let Some(num) = key.to_string().parse::<usize>().ok() {
                            if num > 0 && num <= choices.len() {
                                let idx = num - 1;
                                let choice = &choices[idx];
                                let goto = choice.action.to.clone();
                                let is_disabled = disabled_by_countdown.try_read()
                                    .map(|guard| guard.get(idx).copied().unwrap_or(false))
                                    .unwrap_or(false);
                                // Some paragraph IDs may contain stray whitespaces in the JSON.  Allow
                                // a match either on the original id or its trimmed version so that the
                                // UI does not incorrectly mark a valid choice as disabled.
                                let trimmed_id = choice.action.to.trim();
                                let has_translation = paragraph_has_translation(&paragraphs_vec_keydown, trimmed_id, &current_language_keydown);
                                let is_enabled = (enabled_choices.contains(&choice.action.to.as_ref().to_string())
                                    || enabled_choices.contains(&trimmed_id.to_string()))
                                    && !is_disabled
                                    && has_translation;
                                if is_enabled {
                                    keyboard_state.write().selected_index = idx as i32;
                                    on_choice_click.call((goto.to_string(), idx));
                                }
                            }
                            event.stop_propagation();
                        }
                    }
                }
            },
            onblur: move |_| {
                if should_show_filter_on_blur(*is_mobile.read()) {
                    // Show overlay again when focus is lost on desktop
                    if let Ok(mut guard) = show_filter.try_write() {
                        *guard = true;
                    }
                    // Reset focused state so that text shows "continue_reading" next time
                    if let Ok(mut guard) = is_focused.try_write() {
                        *guard = false;
                    }
                }
            },
            div {
                class: {
                    format!("fixed inset-0 backdrop-blur-sm z-10 flex items-center justify-center transition duration-500 cursor-pointer will-change-transform will-change-opacity {}",
                        if !*show_filter.read() || *is_mobile.read() { "opacity-0 pointer-events-none transform translate-y-2" } else { "opacity-100 transform translate-y-0" }
                    )
                },
                onclick: move |_| {
                    if !*is_mobile.read() {
                        // Safely set signal to avoid ValueDroppedError
                        if let Ok(mut guard) = show_filter.try_write() {
                            *guard = false;
                        }
                        if let Some((_, document)) = get_window_document() {
                            if let Ok(Some(container)) = document.query_selector(".story-content-container") {
                                let _ = container.unchecked_into::<web_sys::HtmlElement>().focus();
                            }
                        }
                    }
                },
                ontransitionend: move |_| {
                    if !*show_filter.read() {
                        // Safely set signal to avoid ValueDroppedError
                        if let Ok(mut guard) = is_focused.try_write() {
                            *guard = true;
                        }
                    }
                },
                div {
                    class: "text-gray-900 dark:text-white paper:text-[#1f2937] text-xl font-bold",
                    {
                        if *is_focused.read() {
                            t!("continue_reading")
                        } else {
                            t!("start_reading")
                        }
                    }
                }
            }
            if *show_paper_tutorial.read() {
                div {
                    class: "fixed inset-0 z-[2000] flex items-center justify-center bg-black/60 px-6",
                    div {
                        class: "w-full max-w-md rounded-2xl bg-white dark:bg-gray-800 paper:bg-[#fef8e7] paper:text-[#1f2937] shadow-xl p-6 space-y-4 text-center",
                        h2 { class: "text-xl font-semibold text-gray-900 dark:text-white paper:text-[#1f2937]", "{t!(\"paper_tutorial_title\")}" }
                        p { class: "text-sm text-gray-600 dark:text-gray-300 paper:text-[#374151] leading-relaxed", "{tutorial_message}" }
                        div {
                            class: "flex items-center justify-center gap-3",
                            button {
                                class: "px-4 py-2 rounded-md border border-gray-300 dark:border-gray-600 paper:border-[#e4d5b2] text-gray-700 dark:text-gray-200 paper:text-[#374151] hover:bg-gray-100 dark:hover:bg-gray-700 paper:hover:bg-[#f0e6cf] transition",
                                onclick: {
                                    let mut settings_ctx = settings_ctx.clone();
                                    let mut show_paper_tutorial = show_paper_tutorial.clone();
                                    move |_| {
                                        settings_ctx
                                            .write()
                                            .settings
                                            .insert(
                                            "paper_mode_tutorial_seen".to_string(),
                                            "true".to_string(),
                                        );
                                    #[cfg(target_arch = "wasm32")]
                                        {
                                            set_setting_to_indexeddb(
                                                "paper_mode_tutorial_seen",
                                                "true",
                                            );
                                        }
                                        show_paper_tutorial.set(false);
                                    }
                                },
                                "{t!(\"paper_tutorial_skip\")}"
                            }
                            button {
                                class: "px-4 py-2 rounded-md bg-green-600 text-white hover:bg-green-700 transition",
                                onclick: {
                                    let mut settings_ctx = settings_ctx.clone();
                                    let mut show_paper_tutorial = show_paper_tutorial.clone();
                                    move |_| {
                                        settings_ctx
                                            .write()
                                            .settings
                                            .insert(
                                            "paper_mode_tutorial_seen".to_string(),
                                            "true".to_string(),
                                        );
                                    #[cfg(target_arch = "wasm32")]
                                        {
                                            set_setting_to_indexeddb(
                                                "paper_mode_tutorial_seen",
                                                "true",
                                            );
                                        }
                                        show_paper_tutorial.set(false);
                                    }
                                },
                                "{t!(\"paper_tutorial_got_it\")}"
                            }
                        }
                    }
                }
            }
            if !is_settings_chapter && !props.chapter_title.is_empty() {
                div {
                    class: "w-full flex items-center justify-center min-h-[calc(100vh_-_56px)]",
                div {
                    class: "relative text-3xl md:text-4xl text-gray-900 dark:text-white paper:text-[#1f2937] text-center w-full select-none flex items-center justify-center pen-texture-text",
                        style: "letter-spacing: 0.1em;",
                        {props.chapter_title.clone()},
                    }
                }
            }
            article {
                class: "prose-sm dark:prose-invert lg:prose-base mx-auto max-w-3xl p-8 text-gray-900 dark:text-white paper:text-[#1f2937] paper:prose paper:prose-base paper:bg-transparent bg-white dark:bg-transparent",
                div {
                    class: "whitespace-pre-wrap space-y-8 story-text-filter",
                    {props.paragraph.read().split('\n')
                        .filter(|p| !p.trim().is_empty())
                        .map(|p| rsx! {
                            p {
                                class: "indent-10 tracking-wide leading-relaxed text-justify",
                                {p}
                            }
                        })
                    }
                }
                if is_settings_chapter || !props.reader_mode {
                    // Always render choice container, only control visibility with opacity
                    ol {
                        class: format!("mt-10 w-full md:w-fit list-decimal transition-opacity transition-transform duration-500 {} {}", fadein_class, choices_opacity_class),
                        {choices.iter().enumerate().map(|(index, choice)| {
                            let caption = choice.caption.clone();
                            let goto = choice.action.to.clone();
                            // Some paragraph IDs may contain stray whitespaces in the JSON.  Allow
                            // a match either on the original id or its trimmed version so that the
                            // UI does not incorrectly mark a valid choice as disabled.
                            let trimmed_id = choice.action.to.trim();
                            let has_translation = paragraph_has_translation(&paragraphs_vec_keydown, trimmed_id, &current_language_keydown);
                            let is_enabled = (enabled_choices.contains(&choice.action.to.as_ref().to_string())
                                || enabled_choices.contains(&trimmed_id.to_string()))
                                && !disabled_by_countdown.try_read()
                                    .map(|guard| guard.get(index).copied().unwrap_or(false))
                                    .unwrap_or(false)
                                && has_translation;
                            let is_selected = keyboard_state.read().selected_index == index as i32;
                            let on_click = {
                                let goto = goto.clone();
                                let on_choice_click = on_choice_click.clone();
                                let mut keyboard_state = keyboard_state.clone();
                                move |evt: Event<MouseData>| {
                                    evt.stop_propagation();
                                    if is_enabled {
                                        keyboard_state.write().selected_index = index as i32;
                                        on_choice_click.call((goto.to_string(), index));
                                    }
                                }
                            };
                            let countdown = countdowns.read().get(index).copied().unwrap_or(0);
                            let max_time = max_times.read().get(index).copied().unwrap_or(0);
                            // Use paragraph content hash to ensure each paragraph's animation is independent
                            let mut hasher = DefaultHasher::new();
                            props.paragraph.read().hash(&mut hasher);
                            let paragraph_hash = hasher.finish();
                            let animation_name = format!("progress-bar-{}-{}", index, paragraph_hash);
                            let keyframes = format!(
                                "@keyframes {} {{ from {{ transform: scaleX(1); }} to {{ transform: scaleX(0); }} }}",
                                animation_name
                            );
                            let duration = format!("{}s", max_time);
                            // Use pre-read values to avoid scope issues
                            let animation_play_state = if countdown_paused { "paused" } else { "running" };
                            let current_paragraph_id_clone = current_paragraph_id_signal.read().clone();
                            let story_ctx_clone = story_ctx.clone();
                            rsx! {
                                li {
                                    class: {{
                                        let base = "p-4 transition duration-200 relative text-gray-900 dark:text-white paper:!text-[#1f2937]";
                                        let enabled = "cursor-pointer hover:text-gray-700 dark:hover:text-gray-300 paper:hover:!text-[#111827] transition-opacity transition-transform";
                                        let disabled = "opacity-50 cursor-not-allowed text-gray-400 dark:text-gray-400 paper:!text-[#9ca3af]";
                                        let selected = "text-gray-900 dark:text-gray-100 paper:!text-[#111827]";
                                        format!(
                                            "{base} {} {}",
                                            if is_enabled { enabled } else { disabled },
                                            if is_selected { selected } else { "" }
                                        )
                                    }},
                                    onclick: on_click,
                                    span { class: "mr-2", {caption.as_ref()} }
                                    { ( *disabled_state_loaded.read() && countdown > 0 && !disabled_by_countdown.try_read()
                                        .map(|guard| guard.get(index).copied().unwrap_or(false))
                                        .unwrap_or(false)
                                        && is_enabled).then(|| rsx! {
                                        style { "{keyframes}" }
                                        div {
                                            class: format!("w-full h-px bg-current mt-2 origin-left will-change-transform {}",
                                                if *time_left_enabled.read() { "" } else { "opacity-0" }
                                            ),
                                            style: format!(
                                                "animation: {} linear {} forwards;animation-play-state:{};animation-delay:0.2s;",
                                                animation_name, duration, animation_play_state
                                            ),
                                            onanimationend: move |_| {
                                                // 只有在 animation 正常運行 (非 paused) 狀態下，才在結束時停用選項
                                                if !countdown_paused {
                                                    let mut arr = disabled_by_countdown.write();
                                                    if !arr.get(index).copied().unwrap_or(false) {
                                                        arr[index] = true;
                                                        // Save disabled state to IndexedDB (excluding settings chapter)
                                                        let is_settings_chapter = story_ctx_clone.read().is_settings_chapter();
                                                        if !current_paragraph_id_clone.is_empty() && !is_settings_chapter {
                                                            let current_paragraph_id_clone_for_db = current_paragraph_id_clone.clone();
                                                            let index_for_db = index;
                                                            spawn_local(async move {
                                                                let _ = set_disabled_choice_to_indexeddb(&current_paragraph_id_clone_for_db, index_for_db as u32).await;
                                                            });
                                                        }
                                                    }
                                                }
                                            },
                                        }
                                    }) }
                                }
                            }
                        })}
                    }
                }
            }
        }
    }
}

// Chromium on desktop can report noticeably larger scroll height deltas when the page
// is effectively non-scrollable (e.g., extra spacing from injected styles). Use a
// generous tolerance so countdown choices still appear after the overlay is dismissed.
const NON_SCROLLABLE_TOLERANCE: i32 = 400;

/// Determine if the choice list should be shown after the overlay has been dismissed.
///
/// This is extracted from the in-component impact logic so that it can be unit-tested.
/// The logic is:
/// 1. If the overlay is still shown (`show_filter == true`) => do not show.
/// 2. If the choices have already been shown once (`has_shown_choices == true`) => show.
/// 3. If a countdown exists and the document is **not** scrollable (`scroll_height <= client_height`) => show.
/// 4. Otherwise => do not show.
#[allow(dead_code)]
pub fn should_show_choices_on_overlay_hide(
    show_filter: bool,
    has_shown_choices: bool,
    has_countdown: bool,
    scroll_height: i32,
    client_height: i32,
) -> bool {
    if show_filter {
        return false;
    }

    if has_shown_choices {
        return true;
    }

    if has_countdown && (scroll_height - client_height) <= NON_SCROLLABLE_TOLERANCE {
        return true;
    }

    false
}

// 1st edit: Append new helper function.
pub fn should_lock_page_scroll(show_filter: bool) -> bool {
    show_filter
}

/// Determine if overlay should reappear when the story content container loses focus.
/// Returns true for desktop (non-mobile) environments so that the overlay is shown again.
#[allow(dead_code)]
pub fn should_show_filter_on_blur(is_mobile: bool) -> bool {
    !is_mobile
}

/// Determine if the user has effectively scrolled to the bottom of the page.
///
/// The calculation needs to accommodate mobile browsers whose UI chrome (e.g. bottom
/// navigation bar in Firefox for Android) can overlay the viewport and thus
/// reduce the *visually* scrollable area. To mitigate this we apply a larger
/// tolerance when `is_mobile` is `true`.
///
/// * `scroll_height`  – document `scrollHeight`
/// * `client_height`  – document `clientHeight`
/// * `scroll_top`     – current vertical scroll offset
/// * `is_mobile`      – whether the device is considered mobile (viewport < 768 px)
///
/// Returns `true` when the bottom is reached within an acceptable tolerance.
pub fn is_scrolled_to_bottom(
    scroll_height: i32,
    client_height: i32,
    scroll_top: i32,
    is_mobile: bool,
) -> bool {
    let tolerance = if is_mobile { 100 } else { 10 };
    (scroll_height - client_height - scroll_top) <= tolerance
}

/*
@layer utilities {
  @keyframes fadein-choices {
    from { opacity: 0; transform: translateY(1.5rem); }
    to { opacity: 1; transform: translateY(0); }
  }
  .animate-fadein-choices {
    animation: fadein-choices 0.7s cubic-bezier(0.4,0,0.2,1) forwards;
    will-change: opacity, transform;
  }
  .opacity-0 { opacity: 0; }
  .opacity-100 { opacity: 1; }
}
*/
